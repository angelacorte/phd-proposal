\documentclass[12pt, a4paper]{article}
%\usepackage{natbib}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[inline]{enumitem}
\usepackage[hidelinks]{hyperref}

\usepackage{myacronyms}
\usepackage{listings}
\usepackage{todonotes}
\newcommand{\note}[3]{\todo[inline,linecolor=#1,backgroundcolor=#1!25,bordercolor=#1]{\textbf{#2:} #3}}
\newcommand{\angela}[1]{\note{blue}{Angela}{#1}}

\newenvironment{inlinelist}{\begin{enumerate*}[label=\emph{(\roman*)}]}{\end{enumerate*}}

\usepackage{cleveref}

\begin{document}

%\title{Towards aggregate operative systems with Aggregate Computing}
\title{Towards cooperative operative environments with Aggregate Computing}
\author{Angela Cortecchia}
\date{\today}
\maketitle
%
%\setlength{\parindent}{0em}
%\setlength{\parskip}{1em}

% ----------------------------------------
\section{State of the art}\label{sec:state-of-the-art}
% Esporre sinteticamente lo “stato dell’arte” relativamente al tema di ricerca prescelto,
% con le indicazioni bibliografiche essenziali.
% Se il progetto fa parte di una ricerca più ampia, evidenziare in modo specifico l’attività specifica che ci si propone di svolgere.
% Inserire inoltre gli elementi essenziali utili a dimostrare la coerenza del tema di ricerca prescelto con il percorso di
% formazione e le esperienze pregresse.
%\paragraph{Collective Adaptive Systems}
\sloppypar
\paragraph{Collective Adaptive Systems and Macroprogramming.}
\ac{cas} are systems composed of multiple autonomous entities, such as devices, sensors, and actuators,
that locally interact to achieve a common global goal~\cite{ferscha2015}.
%
These systems adjust to changes in the environment, system requirements, or operational conditions.
%
\ac{cas} are frequently used in \ac{cps} applications,
where devices collaborate to monitor and control a physical environment or provide a service to users.

Managing a single device in a distributed system can be challenging for several reasons,
such as \textbf{scalability}, \textbf{device heterogeneity},
\textbf{resource constraints}, and the need to adapt to \textbf{dynamic changes}.
%
Transitioning from a \emph{device-centric} approach,
where the collective is not the abstraction target,
to an \emph{aggregate-centric} approach can lead to various advantages, like
\begin{inlinelist}
    \item distributed intelligence,
    \item resource pooling,
    \item adaptability, and
    \item robustness.
\end{inlinelist}
%
The mentioned challenges can be addressed by using \emph{macroprogramming}.

\emph{Macroprogramming}~\cite{casadei2023} refers
to expressing the macroscopic behavior of a system through a single program using
macro-level abstractions.
%
This approach captures system-level behavior while abstracting individual component interactions.
%
Macroprogramming has been used in different contexts like \ac{wsn}~\cite{1440891}, \ac{iot} applications~\cite{noor19,mizzi18} and swarm robotics~\cite{buzz}.

%
%Macroprogramming promotes collective behavior properties, such as self-organization and self-configuration, by declaring
%tasks within specific spatio-temporal regions,
%allowing systems to dynamically adapt to their deployment and spatial positions.

%
%\ac{cas} are systems composed of multiple autonomous entities, such as devices, sensors and actuators,
%that interact to achieve a common goal~\cite{ferscha2015}.
%%
%These systems are known for their ability to adjust to changes in the environment,
%systems requirements, or operational conditions.
%
%\ac{cas} are frequently used in \ac{cps} applications,
%where devices collaborate to achieve a common goal,
%such as monitoring and controlling a physical environment or providing a service to users.
%%
%The coordination of devices in \ac{cas} can be challenging due to the heterogeneity of the devices involved,
%resource constraints, and the need to adapt to dynamic changes in the environment.
%
%Macroprogramming can be used to promote collective behaviors,
%leveraging high-level abstractions and constructs to facilitate global coordination,
%decentralized control, and adaptability in complex systems.
%
%
%\paragraph{Macroprogramming}
%The term \emph{macroprogramming}~\cite{casadei2023} refers to the concept of expressing the macroscopic behavior of a system
%through a single program,
%usually leveraging on macro-level abstractions.
%%
%This paradigm is driven by the need to capture \emph{system-level behavior} while abstracting the behavior and interaction
%of the individual components involved.
%%
%Macroprogramming approaches have been suggested to simplify the development of systems involving many interconnected sensors,
%actuators, and smart devices;
%they can be applied in context like \ac{iot} and \ac{cps}.
%
%Macroprogramming abstractions can promote collective behavior properties,
%such as self-organizing or self-configuring in the context of \ac{cas}.
%%
%By declaring tasks within a specific spatio-temporal region,
%systems can self-organize and effectively perform the task at hand,
%allowing for dynamic adaptation to the current deployment and spatial position of the components involved.
\sloppypar
\paragraph{Self-organization and Field Calculus.}

Coordination models propose that interaction among multiple independent and autonomous software systems can be designed
orthogonally to pure computation, conceptualized as a shared data space.
%
Over time,
various approaches like \textit{Linda}~\cite{ViroliCoordination2012} and \textit{MARS}~\cite{mars} have emerged,
focusing on centralized local components rather than system distribution.
%
Key challenges in distributed systems include openness to environmental changes, large-scale agent coordination,
and intrinsic adaptiveness to ensure system resilience.
%
Addressing these challenges requires a \emph{self-organization and -coordination} approach,
managing logical interactions to
ensure global and robust coordination behavior.

To facilitate self-organization in complex environments, the \emph{coordination field} concept was introduced as a
navigational tool for agents.
%
The tuple-based middleware \textit{TOTA} (Tuples On The Air)~\cite{tota} supports field-based coordination in pervasive
computing applications.
%
Studies on distributed intelligent systems proposed computational fields for managing space-time
computing models, promoting higher abstractions of spatial collective adaptive systems~\cite{JLAMP2019}.

\ac{fc}~\cite{TOCL2019} emerged as a foundational model for coordinating computational devices in physical environments.
%
\ac{fc} was introduced as minimal core calculus with the aim of capturing the fundaments that make use of computational fields:
functions over and with fields, their evolution over time and the construction of field of values from neighbors.
%
It specifies aggregate system behavior through a dynamic network of directly communicating devices,
using functional compositions of operators manipulating computational fields.
%
Local specifications involve asynchronous computational rounds with three phases:
\begin{inlinelist}
    \item \emph{context building},
    \item \emph{program execution}, and
    \item \emph{export sharing}.
\end{inlinelist}
%
Globally,
\ac{fc} aligns individual device behavior with the network's overarching behavior,
specifying mappings for each device's computation round at space-time events.

%\paragraph{Self-organization}
%Coordination models are based on the notion that interaction among multiple independent and autonomous software systems
%can be designed as a space orthogonal to pure computation.
%%
%This idea can be reified into a concept of shared data space, enabling so-called \emph{generative communication}.
%
%Over the course of time, different approaches have been created,
%such as ``Linda''~\cite{ViroliCoordination2012} and ``MARS''~\cite{mars},
%suggesting innovative techniques for programming systems with devices of different nature,
%focusing on the coordination of centralized local components,
%but not on the distribution of the system.
%%
%The main problems that can be encountered in distributed systems are dealing with
%\begin{inlinelist}
%    \item openness, as unexpected environment changes,
%    \item large scale of agents and coordination abstractions to be managed,
%    \item intrinsic adaptiveness, such as the ability to intercept relevant events and react to them,
%    guaranteeing the resilience of the system.
%\end{inlinelist}
%
%The challenges require a \emph{self-organizing and coordination} approach,
%wherein coordination abstractions solely manage logical interactions.
%%
%This ensures the emergence of global and robust patterns of correct coordination behavior.
%
%\paragraph{Field Calculus}
%To facilitate self-organization patterns of agents in complex environments,
%the concept of \emph{coordination field} has been introduced.
%%
%This abstraction serves as a navigational tool for agents over the actual environment.
%
%In this context, the tuple-based middleware \textit{TOTA} (Tuples On The Air)~\cite{tota} has been suggested
%to support field-based coordination for pervasive-computing applications.
%
%Somewhat independently of the challenge of identifying appropriate coordination models for distributed and situated systems,
%several studies have tackled analogous issues in the broader endeavor of constructing distributed intelligent systems.
%%
%This involves promoting higher abstractions of spatial collective adaptive systems.
%
%Among the studies such as for managing space-time computing models for the manipulation of distributed data structures,
%the notion of computational fields was proposed~\cite{JLAMP2019}.
%%
%Consequently, the \ac{fc} was proposed as a foundational model for the coordination of computational devices spread in physical environments,
%also known as \ac{ac}.
%%
%\ac{fc} was introduced as a minimal core calculus with the aim of capturing the fundaments that make use of computational fields:
%functions over and with fields, their evolution over time and the construction of field of values from neighbors.
%
%The main concept of \ac{fc} is to specify the aggregate system behavior of a network of devices,
%where devices that can directly communicate with each other are indicated through a dynamic network relation.
%%
%An example of its application is within a sensor network with a range of a broadcast communication.
%
%The behavior is applied through a functional composition of operators that manipulate the computational fields,
%called specification,
%that can be interpreted locally or globally.
%%
%A local specification can describe a computation on an individual device executed in asynchronous ``computational rounds'',
%including sending or receiving messages from neighbors,
%getting information from sensors and computing the local value of the field.
%%
%Each round is divided in three phases:
%\begin{inlinelist}
%    \item \emph{context building}, where the device collects information from the environment and from the messages
%    received from the neighbors, and aggregates them to build a local context;
%    \item \emph{program execution}, each device executes the program on the context;
%    \item \emph{export sharing}, the device sends messages to its neighbors, containing the results of the computation.
%\end{inlinelist}
%
%In the global view,
%a field calculus expression specifies a mapping associating each computation round of each device to the value that it assumes at that space-time event.
%%
%This dual nature inherently facilitates the alignment of individual device behavior with the overarching global behavior of the entire
%network of devices.

\sloppypar
\paragraph{Aggregate Computing/Programming.}
\ac{ap} (or \ac{ac})~\cite{CASADEI2019252} is a functional macroprogramming approach for the compositional development
of self-adaptive \ac{iot} services,
based on the abstractions of \ac{fc}~\cite{MAMEIZL04}.

\ac{ac} programs the behavior of a distributed system by defining interactions among devices as a whole,
rather than individual device behavior,
shifting the fundamental computation unit from a single device to a collaborative group of devices.
%
This structure supports the specification, analysis, simulation,
and runtime execution of \emph{collective} or \emph{aggregate} services,
independently of specific \ac{iot} architectures~\cite{FI2020-pulverization}.

The paradigm has three key traits:
\begin{inlinelist}
    \item \emph{global stance with global-to-local mapping}, where the target of system design is the entire distributed \ac{iot} ecosystem,
    \item \emph{service compositionality}, describing rich collective services through the functional composition of simpler services,
    \item \emph{abstraction}, enabling adaptivity by abstracting from low-level details.
\end{inlinelist}
%
These attributes are crucial in both the \emph{design phase},
allowing concise and declarative articulation of complex solutions,
and the \emph{operational phase},
providing flexibility in execution specifics and deployment strategies.
%
Each device of the system locally evaluates the program at a certain frequency,
and communicates with neighboring devices when needed.


%\paragraph{Aggregate Computing/Programming}
%\ac{ap} (or \ac{ac})~\cite{CASADEI2019252} is a functional macroprogramming approach for the compositional development of self-adaptive \ac{iot} services,
%based on the abstractions of the \ac{fc}~\cite{MAMEIZL04}.
%
%\ac{ac} allows to program the behavior of a distributed system by defining the interaction among the devices,
%rather than the behavior of each device.
%%
%With this approach,
%the fundamental unit of computation switch from the single device to a collaborative group of devices.
%
%\ac{ac} has the core idea of functionality composing collective behaviors to achieve effective and resilient complex behaviors in dynamic networks. %todo sta frase non ha un senso
%%
%It views a given environment as a whole programmable entity whose parts collaboratively produce and consume services across space and time.
%
%Therefore, its structure supports the specification, analysis, simulation and runtime execution of \emph{collective}
%or \emph{aggregate} services, independently of the specific~\ac{iot} architecture.
%
%This paradigm has three key traits that characterise it:
%\begin{inlinelist}
%    \item \emph{global stance with global-to-local mapping}, where the target of system design is the entire distributed \ac{iot} ecosystem,
%    \item \emph{behaviour compositionality}, whereby a rich collective service can be described in terms of the functional
%        composition of simpler collective services, and
%    \item \emph{abstraction}, by which aggregate services enable adaptivity at different levels by abstracting from low-level
%        issues and details.
%\end{inlinelist}
%%
%These attributes are crucial both in the design phase, where intricate solutions can frequently be articulated concisely
%and declaratively, and in the operational phase, where considerable flexibility is granted to the developers team and the
%platform regarding execution specifics and deployment strategies.
%
%\ac{ac} enables the development of complex programs by the composing of simpler function blocks.
%%
%Therefore, it is defined as a single program for the entire system and every device locally evaluates it at a certain frequency,
%and sends messages with other devices that are considered neighbors in the network if needed.


\sloppypar
\paragraph{Actual tools for Aggregate Computing.}

\subsection{Coherence with the educational path}\label{subsec:coherence-with-the-educational-path}

The research project proposed can be seen as an extension of the research activities
carried out during the Master's degree.

During the Master's degree,
the exploration of \ac{fc} and \ac{ac} began as a project of the course ``Pervasive Computing''.
%
My project's colleagues and I developed a prototype of the ScaFi's engine in Rust,
more specifically the core of the engine inherent to the \ac{fc}.
%
In addition to the development of the engine in Rust,
we also developed a version in Scala 3 of the engine's core that was already implemented in Scala 2,
which is the language used by the ScaFi project.
%
This work provided me with a good foundation in the field of \ac{ac} and \ac{fc}.

The Master's thesis was also focused on the \ac{ac} paradigm.
%
The goal of the thesis was to expand the work done on the Collektive \ac{dsl} previously developed,
by adding the constructs of the \emph{eXchange Calculus}~\cite{AudritoCDSV24} to the language. \angela{todo explain xc and collektive?}
%
At the end of the thesis, a prototype of the language was ready and tested on simple case study,
showing the potential of the language in the development of \ac{ac} applications.
%
The thesis therefore helped me to deepen my knowledge of the \ac{ac} paradigm and to understand the potential
of the language in the development of \ac{ac} applications.

During the development of the Master's degree,
I had the opportunity to apply for a research grant that was awarded to me from the \emph{Consortium GARR},
the Italian ``Group for Research Networks Harmonisation'',
and it is currently ongoing.
%
The research grant has the focus on the extension of the work done on the Collektive \ac{dsl},
by creating a standard library of functions that can be used in the development of \ac{ac} applications,
and various demos to show the functionalities of the language.

Thanks to the work done during the Master's degree and the research grant,
it has been possible to submit a paper to the \emph{IEEE International Conference on Autonomic Computing and Self-Organizing Systems} (ACSOS 2024),
which is currently under review,
about a generalization of the \emph{Vascular Morphogenesis Controller} (VMC) algorithm using the \ac{ac} paradigm.
%
Another paper is currently under submission to the \emph{International Symposium on Distributed Simulation and Real Time Applications} (DS-RT 2024).
%
It is about the development of an architecture and prototype
for monitoring distributed simulations of distributed systems,
where my contribution consists of the development of the simulation used in the evaluation of the architecture,
done using \emph{Collektive}.


% ----------------------------------------
\section{Project description}\label{sec:project-description}
\angela{Esporre la finalità della ricerca e descrivere in maniera sintetica la metodologia d’indagine prescelta e la pianificazione sperimentale per perseguire gli obiettivi prefissati.}
The objective of creating a new generation of operative systems based on \emph{cooperative operative environment}
for opportunistic mobile applications and services is well known in literature,
but few studies have been conducted to effectively develop such systems.

Managing multiple concurrent aggregate operations -- where the execution is distributed over space and time
-- poses a significant challenge that is increasingly necessary.
%
To address this,
a system has been developed for managing \emph{aggregate processes}~\cite{aggregate-processes} based on \ac{fc}.
%
Aggregate processes are concurrent field computations
whose execution and interactions are sustained by a dynamic team of devices,
and whose spatial region can opportunistically change over time.
%
This concept captures
\begin{inlinelist}
    \item aggregate behavior,
    \item dynamicity and context orientation,
    \item intrinsic resiliency;
\end{inlinelist}
and as perks, it offers to
\begin{inlinelist}
    \item limit the consumption of computational resources,
    \item maintain a good quality of service, and
    \item enhance the dynamics of distributed computations.
\end{inlinelist}

These types of processes differ from the concentrated ones.
%
In particular, there are specific issues that arise in the aggregate approach rather than the traditional one.
%
For example, managing process interruptions, determining the owner of a process and the resources it can access,
or understanding what it means to send a signal to a process.

All of these issues are already resolved in the traditional approach,
but they still need to be investigated and addressed in the aggregate approach.
%
For instance, in the aggregate approach termination is managed collectively.
%
However,
there may be situations where a single device decides to terminate processes or where a process using shared
resources loses the right to use them during execution,
introducing a distributed consensus problem.

In practical cases, there may be situations of crowd sensing or crowd steering where,
eventually,
law enforcement realizes that too many people are gathering.
%
Depending on the situation,
these third-party entities can decide to interrupt the crowd-management process.

Another matter not yet addressed is the management of the users in an aggregate environment.
%
There is the need to understand what does it mean to have a user in an aggregate environment,
and how to manage the permissions of the users in the system.

Given the features and innovations that the \emph{aggregate processes} approach brings to the field of \ac{ac},
the idea of exploring and expanding the concept on the basis of \emph{aggregate processes} to the development
of a new generation of operative systems arises.
%
The proposed research project aims to investigate the development of \emph{aggregate operative systems},
based on the \ac{ac} paradigm.
%
The project will focus on capturing some of the key features and roles of an operative system with the \ac{ac} paradigm,
such as the management of:
\begin{itemize}
    \item \textbf{collective devices}: combining the capabilities of more devices to achieve a common goal as a single
        entity or logical resource (sensor and actuation fusion);
    \item \textbf{file system}: there are distributed data that should be put together and managed as a single entity,
        there are already some technologies with this aim, but the aim is to get a right level of abstraction to manage the data
        without knowing the underlying technology;
    \item \textbf{users}: groups and sessions that can dynamically adapt to the environment and collaborate between them;
    \item \textbf{permissions}: access to resources and services based on the role of the user relative to the context in which they are located;
    \item \textbf{signals}: the management of the interruption of the processes and the communication between them.
\end{itemize}

Managing those features with the \ac{ac} paradigm allows
writing a single program for the expected behavior of the system,
even if there are different mechanisms behind the various devices involved.
%
In this way,
the software developer does not have to worry about the underlying technology while developing the logic of the system,
allowing for a more abstract and high-level programming approach and to involve heterogeneous devices in the system.

The paradigm itself of \ac{ac} offers consistency and resilience to failures,
and the possibility to adapt to \emph{dynamic} changes in the environment.

An example of application of the system could be in the management of a drone fleet,
where the drones have to collaborate to achieve a common goal,
such as monitoring a specific area,
but the operating system sees them as a single ``sensor'',
in this way the abstraction of the system is higher and the management of the system is easier.

Or even in the management of a smart city,
where the system has to manage the data of the city and the users,
there may be the need to monitor parking lots so a user can find a free one,
or officers can manage the traffic in the city,
or even the system can manage the lighting of the city based on the presence of people in the streets.

% ----------------------------------------
\section{Expected results}\label{sec:expected-results}
\angela{Descrivere sinteticamente quale apporto la ricerca può fornire all’avanzamento delle conoscenze scientifico-tecnologiche
e le eventuali ricadute sulla società, ponendo in rilievo i profili di originalità dei risultati attesi.}
As a result of the research project,

%date delle metriche devo trovare in confronto a quelle dove vado a migliorare

% ----------------------------------------
\section{Subdivision of the project and timeline}\label{sec:subdivision-of-the-project-and-timeline}
\angela{Illustrare lo sviluppo temporale della ricerca nei 3 anni di progetto, con particolare enfasi sul primo anno.}

\sloppypar
\paragraph{First year}
In the first year of the project,
the focus is
on investigating the state of the art of the \ac{ac} paradigm and the development of the \emph{aggregate processes} system.
%
The goal is to understand the issues that can arise in a cooperative environment and to address them.

Then, it is expected to develop a prototype with the basic functionalities,
such as the management of the aggregate processes.

\sloppypar
\paragraph{Second year}
In the second year,
the goal is to expand the functionalities of the system to manage multi-user,
rights and permissions, and aggregate peripherals devices.

\sloppypar
\paragraph{Third year}
In the third and final year,
the goal is to use the final prototype of the system in simulated real-world scenarios
and to evaluate its performance and effectiveness.

% ----------------------------------------
\section{Proposed evaluation criteria}\label{sec:proposed-evaluation-criteria}
\angela{Descrivere sinteticamente quali modalità si intendono utilizzare durante lo svolgimento del progetto per il monitoraggio
e la valutazione del raggiungimento dei risultati attesi.}

% ----------------------------------------
\bibliographystyle{IEEEtran}
\bibliography{bibliography}

\end{document}
